---
title: 8-puzzle
date: 2025-03-29
links:
  - name: 8 퍼즐
    url: https://github.com/yeeuneey/8-puzzle.git
    icon: link
tags:
  - Ai
  - Python
---

8-puzzle을 해결하는 탐색 알고리즘을 구현하는 프로젝트를 진행하였습니다.

초기 코드에서는 경로를 표현할 때 노드 리스트를 사용하는 구조로 되어 있으며 모든 상태를 저장하도록 구현되어 있기 때문에 탐색 중인 노드 하나를 위해 경로 전체를 복사하여 저장한다는 문제점이 있다고 판단하였습니다. 예를 들어서 DFS에서 깊이가 1000 이상이 되면 1000개 리스트가 매번 복사되기 때문에 탐색 깊이가 깊어질수록 성능 저하와 메모리 낭비가 발생하는 문제가 생겨, 결과 출력까지 걸리는 시간이 너무 낭비되는 느낌을 받았습니다. 따라서 다음과 같이 코드를 수정하였습니다.

node 클래스를 도입하여서 state, action, cost, parent 의 정보를 하나의 객체에 캡슐화했습니다. path() 메서드는 현재 상태의 노드부터 루트 노드인 시작 상태까지의 경로에서 어떠한 action(up, down, left, right)들을 했는지 parent를 따라 거슬러 가면서 action을 리스트에 저장하고 reverse()를 취하여 올바른 순서대로 반환하도록 구현하였습니다. 즉, action 리스트를 반환하는 역할을 합니다. 각각의 탐색 알고리즘들에서 동일한 node 클래스를 사용하도록 설계하여 알고리즘 간 구조를 통일함으로써 효율성을 높이는 데 초점을 맞췄습니다.

DFS는 깊이 우선 탐색이기 때문에 스택 기반으로 last in, first out 구조를 사용합니다. node(start)를 스택에 넣고, 가장 나중에 들어온 노드를 pop() 하여서 탐색합니다. 목표에 도달하면 node.path()로 경로를 반환합니다. node.parent 를 통해 경로를 기억합니다.

BFS는 너비 우선 탐색이기 때문에 first in, first out 큐를 사용합니다. node(start)를 큐에 넣고, 가장 먼저 들어온 노드를 popleft() 하여서 탐색합니다. 자식은 새로운 노드로 큐에 넣습니다. node.path()로 도달 경로를 반환합니다.

UCS는 비용을 기준으로 합니다. 가장 비용이 작은 노드부터 확장합니다. 시작 노드를 (0, node(start)) 형태로 우선순위 큐에 넣고 heapq에서 가장 비용이 작은 노드를 꺼내고, 자식 상태를 누적 비용을 포함한 노드로 생성합니다. 비용은 힙 정렬되고 __lt__() 메서드로 비교합니다. 

A*는 UCS와 동일하게 비용 기준으로, 시작 상태를 큐에 저장합니다. heapq에서 f(n)이 가장 작은 노드를 꺼냅니다. 힙 정렬할 때 튜플의 첫 번째 요소가 되는 f 값을 기준으로 해서 우선순위 정렬합니다. 휴리스틱은 노드 내부에는 없으나 외부에서 계산된 후 전달됩니다.

다양한 결과들을 분석하기 위해 main.py을 수정하여 각 알고리즘들의 난이도 설정, 즉, 퍼즐을 섞는 횟수를 다르게 설정함에 따라 시간이 얼마나 걸리는지, 총 움직인 횟수는 몇 번인지 결과를 요약해서 출력하도록 설계하였습니다. createRandomEigthPuzzle()이 매 실행마다 새로운 다른 퍼즐들을 생성하기 때문에 이에 따라 같은 moves일지라도 결과에 편차가 존재했습니다. 따라서 같은 퍼즐에 대해서 여러 번 실행함으로 평균을 확인하여 분석하는 방식을 선택하였습니다.

<!--more-->
